# Storage Backend Examples

This directory contains comprehensive examples demonstrating the different storage backends available in the Stratum V2 Storage role.

## Available Examples

### üß† Memory Backend Example
**File:** `memory_backend.rs`  
**Command:** `cargo run --example memory_backend --features memory-backend`

Demonstrates the in-memory storage backend with comprehensive mock data:
- Fast initialization and operations
- Full API demonstration with realistic data
- Performance metrics and analytics
- Zero persistence (data lost on shutdown)
- Perfect for development and testing

**Features shown:**
- Share accounting data storage
- Share record tracking with validation results
- Block discovery logging
- Batch acknowledgment records
- Duplicate detection
- Channel statistics and global analytics
- Health monitoring

### üíæ SQLite Backend Example  
**File:** `sqlite_backend.rs`  
**Command:** `cargo run --example sqlite_backend --features sqlite-backend`

Demonstrates the SQLite storage backend with full persistence:
- Database schema creation and initialization
- ACID transaction guarantees
- Data persistence across restarts
- SQL-based queries and analytics
- File-based storage with compact format

**Features shown:**
- All memory backend features, plus:
- Database file creation and management
- Persistence verification (close/reopen test)
- SQL schema with proper indexing
- Transaction safety
- Database file size reporting

### ‚öñÔ∏è Backend Comparison
**File:** `backend_comparison.rs`  
**Command:** `cargo run --example backend_comparison --features sqlite-backend`

Side-by-side comparison of storage backends:
- Performance benchmarking
- Feature matrix comparison
- Use case recommendations
- Real metrics and timing data

**Comparison metrics:**
- Initialization time
- Data insertion performance  
- Query operation speed
- Memory vs disk usage
- Persistence capabilities

## Mock Data

All examples use the same realistic mock dataset generated by `mock_data.rs`:

- **5 channels** with different types (mining, extended, standard)
- **70 share records** with ~83% acceptance rate
- **3 block discoveries** across different channels  
- **15 batch acknowledgments** demonstrating batch processing
- **Realistic timestamps** spread over time
- **Varied difficulty levels** and work amounts
- **Different validation outcomes** (valid, failed, batch acks, block finds)

## Running Examples

### Prerequisites
```bash
# For memory backend examples
cargo run --example memory_backend --features memory-backend

# For SQLite backend examples  
cargo run --example sqlite_backend --features sqlite-backend

# For comparison (includes both backends)
cargo run --example backend_comparison --features sqlite-backend
```

### Example Output

#### Memory Backend
- **Initialization:** ~0.001ms (near-instant)
- **Data Insertion:** ~0.09ms (extremely fast)
- **Query Operations:** ~0.03ms (fastest possible)
- **Storage:** RAM only (no persistence)

#### SQLite Backend  
- **Initialization:** ~8ms (schema creation)
- **Data Insertion:** ~62ms (ACID transactions)
- **Query Operations:** ~0.6ms (indexed queries)
- **Storage:** 68KB database file (persistent)

## Use Case Guide

### üß† Choose Memory Backend For:
- **Development & Testing**: Fast iteration cycles
- **Unit Tests**: Isolated, repeatable tests
- **Benchmarking**: Maximum performance measurement
- **Temporary Processing**: No persistence needed
- **High Throughput**: When disk I/O is a bottleneck

### üíæ Choose SQLite Backend For:
- **Production**: Reliable data persistence  
- **Analytics**: Historical data analysis
- **Audit Trails**: Compliance and tracking
- **Recovery**: Data survives crashes/restarts
- **Reporting**: SQL-based queries and exports

## Integration Examples

These examples also serve as integration guides showing how to:

1. **Initialize storage backends** with proper error handling
2. **Store different data types** (accounting, shares, blocks, batches)
3. **Query and analyze data** with filtering and pagination
4. **Handle concurrent operations** safely
5. **Monitor system health** and performance
6. **Implement cleanup procedures** for old data

## Database Inspection

For SQLite examples, you can inspect the generated database:

```bash
# View database schema
sqlite3 example_storage.db ".schema"

# Query share records
sqlite3 example_storage.db "SELECT channel_id, COUNT(*) FROM share_records GROUP BY channel_id"

# Check block discoveries
sqlite3 example_storage.db "SELECT * FROM block_records"

# View batch acknowledgments  
sqlite3 example_storage.db "SELECT * FROM batch_acknowledgments ORDER BY timestamp DESC"
```

The database uses proper indexing for performance and follows SQLite best practices for the mining pool data model.